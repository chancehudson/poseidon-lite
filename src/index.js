import unstringifyBigInts from './unstringify'

const optCache = {}
const F = BigInt(
  '21888242871839275222246405745257275088548364400416034343698204186575808495617'
)

// Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
// Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001

// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
// And rounded up to nearest integer that divides by t
const N_ROUNDS_F = 8
// valid t values 2, 3, 4, 8, 12, 16
// 0 values indicate invalid t value
const N_ROUNDS_P = [56, 57, 56, 0, 0, 0, 64, 0, 0, 0, 60, 0, 0, 0, 64]

const M4 = [
  [5n, 7n, 1n, 3n],
  [4n, 6n, 1n, 1n],
  [1n, 3n, 5n, 7n],
  [1n, 1n, 4n, 6n],
]

// multiply a vector by a matrix of the same height
const _mulVecMat = (vec, mat) => {
  const out = []
  for (let x = 0; x < vec.length; x++) {
    let o = 0n
    for (let y = 0; y < vec.length; y++) {
      o = o + mat[x][y] * vec[y]
    }
    out.push(o % F)
  }
  return out
}

// multiply a vector by a smaller or equal size matrix
const mulVecMat = (vec, mat) => {
  if (vec.length % mat.length !== 0)
    throw new Error('Vector length must be a multiple of matrix height')
  const len = mat.length
  const out = []
  for (let z = 0; z < vec.length / len; z++) {
    out.push(..._mulVecMat(vec.slice(z * len, (z + 1) * len), mat))
  }
  return out
}

const pow5 = (v) => {
  let o = v * v
  return (v * o * o) % F
}

async function poseidon(_inputs) {
  const inputs = _inputs.map((i) => BigInt(i))
  if (inputs.length <= 1) {
    throw new Error('poseidon-lite: Not enough inputs')
  }
  if (inputs.length - 2 > N_ROUNDS_P.length) {
    throw new Error('poseidon-lite: Too many inputs')
  }
  if (inputs.length >= 4 && inputs.length % 4 !== 0) {
    throw new Error(
      `Invalid input length ${inputs.length}, input length must be 2, 3, or a multiple of 4`
    )
  }

  const t = inputs.length
  const nRoundsF = N_ROUNDS_F
  const nRoundsP = N_ROUNDS_P[t - 2]
  if (!nRoundsP) throw new Error('Invalid t value')

  // TODO: maybe put the deserialization logic in the constants file to avoid
  // the optCache here
  const { default: opt } = await import(`./constants/${t - 1}`)

  const { C, M } = optCache[t] ?? unstringifyBigInts(opt)
  optCache[t] = { C, M }

  if (M.length !== t) {
    throw new Error(
      `poseidon-lite: Incorrect M length, expected ${t} got ${M.length}`
    )
  }

  // external round matrix
  const M_E = t % 4 === 0 ? M4 : M

  // apply an initial MDS mul to the input state
  let state = mulVecMat(inputs, M_E)

  for (let x = 0; x < nRoundsF + nRoundsP; x++) {
    const isExternal = x < nRoundsF / 2 || x >= nRoundsF / 2 + nRoundsP
    for (let y = 0; y < state.length; y++) {
      state[y] = pow5(state[y] + C[x * t + y])
      if (!isExternal) break
    }
    state = mulVecMat(state, isExternal ? M_E : M)
  }
  return state[0]
}

module.exports = poseidon
